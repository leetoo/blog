<!DOCTYPE html>
<html lang="en-gb">
    <head>
         
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mdoc test</title>
        
        <style>

    html body {
        font-family: 'Lato', sans-serif;
        background-color: white;
    }

    :root {
        --accent: blue;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://blog.ruimorais.com/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-light.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.54.0" />
        

        
    </head>

    
    
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    

    <body>
         
        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Mdoc test</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/post/">Posts</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:me@example.com"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/username/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://twitter.com/username/"><i class="fa fa-twitter"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/username/"><i class="fa fa-linkedin"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.stackoverflow.com/username/"><i class="fa fa-stack-overflow"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/post/post/">Mdoc test</a></h4>
    <h5>February 8, 2019</h5>
    

</div>


    <br> <div class="text-justify"><p>Let&rsquo;s see if mdoc validates the following snippet</p>

<pre><code class="language-scala">val x = 2
// x: Int = 2

val y = 4
// y: Int = 4
x + y
// res0: Int = 6
</code></pre>

<hr />

<p>title: &ldquo;IO &amp; Logging Capabilities&rdquo;
date: 2018-09-24
draft: false
tags: [&ldquo;Cats&rdquo;, &ldquo;Cats Effect&rdquo;, &ldquo;Cats MTL&rdquo;, &ldquo;Logging&rdquo;, &ldquo;Refined&rdquo;, &ldquo;Scala&rdquo;]
categories: [&ldquo;Scala&rdquo;]
mathjax: true</p>

<h2 id="mathjaxenablesingledollar-true">mathjaxEnableSingleDollar: true</h2>

<p>Using newtypes and type classes, we create a wrapper around <a href="https://typelevel.org/cats-effect/datatypes/io.html"><code>IO</code></a> with support for logging capabilities. This approach keeps log entries as values, enables log aggregation, and supports <a href="https://logback.qos.ch/manual/mdc.html">diagnostic contexts</a>, while also making logging easily testable. For dispatching logs, any preferred library can be used.</p>

<h2 id="logging-challenges">Logging Challenges</h2>

<p>When log entries aren&rsquo;t values, it&rsquo;s difficult to test logging. How would we test what gets output from <code>println</code> or <code>logger.info</code>? Hopefully we&rsquo;ve defined a <code>Logger[F]</code> trait to enable testing and abstracting over the effect type <code>F[_]</code> (e.g. <code>IO</code>). Even with a trait in place, there are still a few things left to be desired.</p>

<ul>
<li><p><em>Log entries are spread throughout the application. It&rsquo;s difficult to locate all of them.</em> While this gives great flexibility, it can be painful to understand what and where an application is logging, especially when coming back to the code later on.</p></li>

<li><p><em>Logging code is not separated from other concerns.</em> Since it&rsquo;s easy to put in an extra log expression, code for what and how  entries get logged is often mixed with other concerns, instead of cleanly separating the different concerns.</p></li>

<li><p><em>Without log accumulation, it&rsquo;s tricky to understand how a request was processed.</em> Most often, we&rsquo;ll need some identifier for the request, so we can later piece together all log entries for the request. This is especially true when we&rsquo;re processing several requests in parallel.</p></li>

<li><p><em>In tests, we&rsquo;re forced to assert on messages.</em> It&rsquo;s a good idea to assert on what messages are dispatched, but we don&rsquo;t want to always assert on the message, since we&rsquo;d then be forced to manually update several tests as we change the message.</p></li>
</ul>

<p>The solution to these challenges is to model log entries as values. We&rsquo;ll also see how we can add explicit support for log accumulation, take full control over exactly when log messages are being dispatched, and make testing our logging easy.</p>

<h2 id="introducing-monadlog">Introducing MonadLog</h2>

<p>The <code>MonadLog</code> type class, defined below, represents an immutable append-only log, where we can also replace the log with an empty one. Essentially, we can append log entries <code>E</code> with <code>log</code>, and then extract them again in context <code>G[_]</code> with <code>extract</code>. We can also clear all logs with <code>clear</code>. By combining <code>extract</code> and <code>clear</code>, we can write <code>flush</code>, which clears the logs after having dispatched them, using the provided dispatch function <code>G[E] =&gt; F[Unit]</code>.</p>

<pre><code class="language-scala">import cats.{Applicative, Monad, MonoidK}

trait MonadLog[F[_], G[_], E] {
  val monad: Monad[F]

  val applicative: Applicative[G]

  val monoidK: MonoidK[G]

  import monad.{as, flatMap}

  def log(e: E): F[Unit]

  def clear[A](fa: F[A]): F[A]

  def extract[A](fa: F[A]): F[(A, G[E])]

  def flush[A](fa: F[A])(f: G[E] =&gt; F[Unit]): F[A] =
    clear(flatMap(extract(fa)) { case (a, ge) =&gt; as(f(ge), a) })
}
</code></pre>

<p>If you&rsquo;re familiar with <a href="https://github.com/typelevel/cats-mtl">cats-mtl</a>, <code>log</code> looks a bit like <code>tell</code> from <a href="https://github.com/typelevel/cats-mtl/blob/master/core/src/main/scala/cats/mtl/FunctorTell.scala"><code>FunctorTell</code></a>, and <code>extract</code> reminds us of <code>listen</code> from <a href="https://github.com/typelevel/cats-mtl/blob/master/core/src/main/scala/cats/mtl/FunctorListen.scala"><code>FunctorListen</code></a>. The main difference is that <code>log</code> is strictly an append operation as shown by the following laws. These laws are in addition to laws for <code>Monad[F]</code>, <code>Applicative[G]</code>, <code>MonoidK[G]</code>.</p>

<pre><code class="language-scala">import cats.laws.IsEqArrow
import cats.syntax.applicative._
import cats.syntax.apply._
import cats.syntax.functor._
import org.typelevel.discipline.Laws

trait MonadLogLaws[F[_], G[_], E] extends Laws {
  implicit val logInstance: MonadLog[F, G, E]
  implicit val monad: Monad[F] = logInstance.monad
  implicit val applicative: Applicative[G] = logInstance.applicative
  implicit val monoidK: MonoidK[G] = logInstance.monoidK

  import logInstance._
  private val G: MonoidK[G] = monoidK

  def clearRemovesLog(e: E) =
    clear(log(e)) &lt;-&gt; ().pure[F]

  // Same as FunctorListen#listenAddsNoEffects
  def extractAddsNoEffects[A](fa: F[A]) =
    extract(fa).map(_._1) &lt;-&gt; fa

  def extractRespectsClear[A](fa: F[A]) =
    extract(clear(fa)) &lt;-&gt; clear(fa).map((_, G.empty[E]))

  // Similar to FunctorListen#listenRespectsTell
  def extractRespectsLog(e: E) =
    extract(log(e)) &lt;-&gt; log(e).map((_, e.pure[G]))

  def extractRespectsLogs(e1: E, e2: E) =
    extract(log(e1) *&gt; log(e2)) &lt;-&gt; (log(e1) *&gt; log(e2))
      .map((_, G.combineK(e1.pure[G], e2.pure[G])))
}
</code></pre>

<p>As far as concrete types go, <code>F[_]</code> will be our <code>IO</code> wrapper type. <code>MonadLog</code> requires <code>Applicative[G]</code> and <code>MonoidK[G]</code>, and we will have to require <code>Foldable[G]</code> to be able to write the dispatch function for <code>flush</code>. Ideally, <code>G[_]</code> should support constant time $\mathcal{O}(1)$ append and a single $\mathcal{O}(n)$ in-order fold. The recently added <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/data/Chain.scala"><code>Chain</code></a> in Cats does fit those requirements. The log entry type <code>E</code> is up to us to define, and we&rsquo;ll define it as <code>LogEntry</code> in the next section.</p>

<h2 id="defining-log-entries">Defining Log Entries</h2>

<p>We will model log entries with <code>LogEntry</code>, which consists of a <code>LogLevel</code> and a <code>NonEmptyString</code> message. Let&rsquo;s start by defining <code>LogLevel</code>. A log level (<code>info</code>, <code>warning</code>, <code>error</code>, &hellip;), is essentially an ordered set of levels. We use a wrapper around a <a href="https://github.com/fthomas/refined">refinement type</a> for <code>Int</code> to represent the log levels. Values correspond to the severity levels used by <a href="https://en.wikipedia.org/wiki/Syslog#Severity_level">syslog</a> and log management systems like <a href="https://www.graylog.org">Graylog</a>. Note that we could have used <code>Byte</code>, but there is no support for <code>Byte</code> literals in Scala, so the definition would not be as concise.</p>

<pre><code class="language-scala">import cats.Order
import cats.instances.int._
import cats.instances.order._
import cats.syntax.contravariant._
import eu.timepit.refined.W
import eu.timepit.refined.api.Refined
import eu.timepit.refined.auto._
import eu.timepit.refined.cats.refTypeOrder
import eu.timepit.refined.numeric.Interval

sealed abstract class LogLevel(val value: LogLevel.Value)

object LogLevel {
  type Value = Int Refined Interval.Closed[W.`0`.T, W.`7`.T]

  case object Error extends LogLevel(3)
  case object Warning extends LogLevel(4)
  case object Info extends LogLevel(6)
  case object Debug extends LogLevel(7)

  implicit val logLevelOrder: Order[LogLevel] =
    Order[Value].contramap(_.value)
}
</code></pre>

<p>We can then define <code>LogEntry</code> as follows, together with any log entries we want. We&rsquo;ve now effectively already solved the first logging challenge: log entries are now in a single place, and it should be rather easy to figure out where they&rsquo;re being used throughout the application.</p>

<pre><code class="language-scala">import cats.syntax.show._
import cats.instances.string._
import eu.timepit.refined.cats.refTypeShow
import eu.timepit.refined.types.numeric.NonNegInt
import eu.timepit.refined.types.string.NonEmptyString

sealed abstract class LogEntry {
  def level: LogLevel
  def message: NonEmptyString
}

object LogEntry {
  case object ApplicationStarted extends LogEntry {
    override def level: LogLevel = LogLevel.Info
    override def message: NonEmptyString = &quot;Application started&quot;
  }

  final case class ReceivedRequest(request: NonEmptyString) extends LogEntry {
    override def level: LogLevel = LogLevel.Info
    override def message: NonEmptyString =
      NonEmptyString.unsafeFrom(show&quot;Received request: $request&quot;)
  }

  final case class RequestStillFailing(retries: NonNegInt) extends LogEntry {
    override def level: LogLevel = LogLevel.Error
    override def message: NonEmptyString =
      NonEmptyString.unsafeFrom(show&quot;Request still failing after $retries retries&quot;)
  }
}
</code></pre>

<p>For log entries without parameters, we can use <code>case object</code>s, and for entries with parameters, we use <code>case class</code>es. Note that we can vary both the log level and message depending on the arguments. This bring us to the second logging challenge: logic relating to how and what gets logged is now encapsulated in the <code>LogEntry</code>, rather than mixed with other concerns.</p>

<p>We use the <code>show</code> interpolator to generate <code>String</code>s with <a href="https://typelevel.org/cats/typeclasses/show.html"><code>Show</code></a> instances, rather than relying on <code>toString</code>, for extra compile-time safety. With <code>String</code> interpolation, we cannot rely on compile-time refinement, so we have to wrap our message in <code>NonEmptyString.unsafeFrom</code>. It&rsquo;s still clear the message is not empty.</p>

<p>Finally, since we&rsquo;re looking to support <a href="https://logback.qos.ch/manual/mdc.html">diagnostic contexts</a>, we&rsquo;ll define <code>MdcEntry</code> for that purpose.</p>

<pre><code class="language-scala">sealed abstract class MdcEntry(
  val key: NonEmptyString,
  val value: NonEmptyString
)

object MdcEntry {
  final case class TraceToken(override val value: NonEmptyString)
      extends MdcEntry(&quot;traceToken&quot;, value)
}
</code></pre>

<h2 id="a-logging-algebra">A Logging Algebra</h2>

<p>Now that we&rsquo;ve defined the relevant logging models, let&rsquo;s focus our attention on functions. We&rsquo;re going to define an algebra in final tagless style, but before doing so, we&rsquo;re going to need functions for determining the <code>LogLevel</code> and <code>NonEmptyString</code> message from log entries <code>G[LogEntry]</code>. We are going to have to require <code>Foldable[G]</code> below to implement these functions.</p>

<p>We define the log level of <code>G[LogEntry]</code> as the most critical level among the log entries. This means we want the lowest level, since level 3 is for <code>Error</code> and level 7 is for <code>Debug</code>. We have already defined <code>Order[LogLevel]</code> and can make use of it here.</p>

<pre><code class="language-scala">import cats.Foldable
import cats.syntax.foldable._

def logLevel[G[_]: Foldable](entries: G[LogEntry]): Option[LogLevel] =
  entries.minimumOption(Order.by(_.level)).map(_.level)
</code></pre>

<p>For the log message of <code>G[LogEntry]</code>, we have more options available, but will go with the following.</p>

<ul>
<li><p>If <code>G[LogEntry]</code> is empty, there are no log entries, so return <code>None</code>.</p></li>

<li><p>If <code>G[LogEntry]</code> contains a single entry, return the message of that entry.</p></li>

<li><p>If <code>G[LogEntry]</code> has two or more entries, prepend <code>-</code> to the entries, and separate by newline.</p></li>
</ul>

<p>Following is an example of a message for two log entries.</p>

<pre><code class="language-nohighlight">- Received request: test
- Request still failing after 3 retries
</code></pre>

<p>There are multiple ways to write such a function. One way, which uses a single fold, but likely is quite slow due to the heavy use of <code>String</code> concatenation, is the following. Depending on your use case, you might want to explore writing more efficient variants of this function. Note that we make use of <code>Eval</code> to avoid constructing the <code>NonEmptyString</code> in cases where we&rsquo;re trying to log at a level which has been disabled.</p>

<pre><code class="language-scala">import cats.{Always, Eval, Semigroup}
import cats.syntax.option._
import cats.syntax.semigroup._

implicit val nonEmptyStringSemigroup: Semigroup[NonEmptyString] =
  Semigroup.instance((a, b) =&gt; NonEmptyString.unsafeFrom(a.value ++ b.value))

def logMessage[G[_]: Foldable](entries: G[LogEntry]): Option[Eval[NonEmptyString]] = {
  def entry(e: LogEntry): NonEmptyString =
    (&quot;- &quot;: NonEmptyString) combine e.message

  def append(s: NonEmptyString, e: LogEntry): NonEmptyString =
    s combine &quot;\n&quot; combine entry(e)

  def combine(a: LogEntry, b: LogEntry): NonEmptyString =
    append(entry(a), b)

  entries
    .foldLeft[Option[(Option[LogEntry], Eval[NonEmptyString])]](None) {
      case (None, a)               =&gt; (a.some -&gt; Always(a.message)).some
      case (Some((Some(a), _)), b) =&gt; (none -&gt; Always(combine(a, b))).some
      case (Some((None, a)), b)    =&gt; (none -&gt; a.map(append(_, b))).some
    }
    .map { case (_, message) =&gt; message }
}
</code></pre>

<p>We&rsquo;re now ready to define the <code>Logging</code> algebra as follows.</p>

<pre><code class="language-scala">trait Logging[F[_], G[_]] {
  def log(entry: LogEntry): F[Unit]
  def logNow(entry: LogEntry, mdc: G[MdcEntry]): F[Unit]
  def dispatchLogs[A](fa: F[A], mdc: G[MdcEntry]): F[A]
  def extractLogs[A](fa: F[A]): F[(A, G[LogEntry])]
}
</code></pre>

<p>The <code>log</code> function accepts a <code>LogEntry</code> and stores it in a <code>F[Unit]</code>. The idea is that we compose several <code>F[_]</code> in our application, and accumulate the logs from included <code>log</code> expressions. At some point we&rsquo;ll call <code>dispatchLogs</code>, which accepts the diagnostic context, and dispatches the logs using <code>flush</code> on <code>MonadLog</code>. The <code>logNow</code> function logs the provided <code>LogEntry</code>, but immediately dispatches it with <code>dispatchLogs</code>, like how a normal log expression would work. Finally, we&rsquo;re including <code>extractLogs</code> as it can be useful to analyse logs, e.g. in order to derive certain metrics, or for testing purposes.</p>

<p>In practice, you might add more useful functions to <code>Logging</code>. For example, overloaded versions of the <code>logNow</code> and <code>dispatchLogs</code> functions which do not require you to pass an empty <code>G[_]</code> whenever you don&rsquo;t want a diagnostic context. We can easily add those functions by also requiring <code>MonoidK[G]</code>. Other candidates include <code>logN</code> and <code>logNowN</code> for logging multiple entries at once.</p>

<p>Let&rsquo;s take a look at how we could implement <code>Logging</code>. The main function of interest is <code>dispatchLogs</code>, which makes use of the <code>logLevel</code> and <code>logMessage</code> functions we wrote before. If there are no logs accumulated when <code>dispatchLogs</code> gets called, we&rsquo;ll simply not do anything. Assuming there are logs to dispatch, we dispatch them with the provided <code>dispatch</code> function. This function will finally log the accumulated logs with a logging library.</p>

<pre><code class="language-scala">import cats.instances.option._

object Logging {
  def create[F[_], G[_]](dispatch: (Eval[NonEmptyString], G[MdcEntry], LogLevel) =&gt; F[Unit])(
    implicit F: MonadLog[F, G, LogEntry],
    G: Foldable[G]
  ): Logging[F, G] =
    new Logging[F, G] {
      override def log(entry: LogEntry): F[Unit] =
        F.log(entry)

      override def logNow(entry: LogEntry, mdc: G[MdcEntry]): F[Unit] =
        dispatchLogs(log(entry), mdc)

      override def dispatchLogs[A](fa: F[A], mdc: G[MdcEntry]): F[A] =
        F.flush(fa) { entries =&gt;
          (logMessage(entries), mdc.some, logLevel(entries))
            .mapN(dispatch)
            .getOrElse(F.monad.unit)
        }

      override def extractLogs[A](fa: F[A]): F[(A, G[LogEntry])] =
        F.extract(fa)
    }
}
</code></pre>

<h2 id="the-iolog-newtype">The IOLog Newtype</h2>

<p>What remains to do before we can use our <code>Logging</code> algebra? We need to define the <code>dispatch</code> function with our logging library of choice, and we need to implement <code>MonadLog</code> for our effect type. We&rsquo;ll start by implementing <code>MonadLog</code> for a wrapper type around <code>IO</code>, since <code>MonadLog</code> cannot directly be implemented for <code>IO</code>. We&rsquo;ll call this wrapper type <code>IOLog</code>.</p>

<pre><code class="language-scala">import cats.data.Chain
import cats.effect.IO

object effects {
  import IOLog.Context

  final case class IOLog[A, E](toIO: IO[Context[A, E]])

  object IOLog {
    final case class Context[A, E](logs: Chain[E], value: A)
  }
}
</code></pre>

<p>There are a couple of things worth highlighting in the definition above.</p>

<ul>
<li><p><code>IOLog</code> is a wrapper around <code>IO</code> with a <code>Context</code> containing the accumulated logs. We could have used <code>extends AnyVal</code> as the newtype here, and there are also <a href="https://github.com/estatico/scala-newtype">alternative newtype encodings</a> without any kind of runtime overhead.</p></li>

<li><p>Having to wrap values with <code>Context</code> is the cost of achieving log accumulation. For simplicity, we&rsquo;re using a <code>case class</code> for <code>Context</code>, but we could use a more compact representation, like e.g. a tuple.</p></li>
</ul>

<p>Notice that <code>IO[Context[A, E]]</code> looks like <code>IO[(Chain[E], A)]</code> without the <code>case class</code>. This happens to be the exact definition of <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/data/WriterT.scala"><code>WriterT</code></a>. This means we can define <code>IOLog</code> using <code>WriterT</code> instead, and we have just saved ourselves having to write the newtype above.</p>

<pre><code class="language-scala">import cats.data.WriterT

type IOLog[A, E] = WriterT[IO, Chain[E], A]
</code></pre>

<p>In our case, the log entry <code>E</code> in <code>IOLog</code> will be <code>LogEntry</code>, so we define a type alias <code>AIO</code> for it.</p>

<pre><code class="language-scala">type AIO[A] = IOLog[A, LogEntry]
</code></pre>

<p><code>AIO</code> can be thought of as &lsquo;Application <code>IO</code>&rsquo; or &lsquo;All-In-One&rsquo;.</p>

<h2 id="type-class-instances">Type Class Instances</h2>

<p>To use <code>IOLog</code> as our <code>F[_]</code> in the application, we&rsquo;ll have to rely on the <a href="https://typelevel.org/cats-effect/typeclasses/">type classes</a> in Cats Effect. Luckily, Cats Effect already provides type class instances for <code>WriterT</code>, so we only have to implement <code>MonadLog</code> for <code>IOLog</code>. We can go one step further and implement <code>MonadLog</code> for <code>WriterT</code> more generally.</p>

<pre><code class="language-scala">implicit def writerTMonadLog[F[_], G[_], E](
  implicit
  M: Monad[WriterT[F, G[E], ?]],
  F: Applicative[F],
  A: Applicative[G],
  K: MonoidK[G]
): MonadLog[WriterT[F, G[E], ?], G, E] =
  new MonadLog[WriterT[F, G[E], ?], G, E] {
    override val monad: Monad[WriterT[F, G[E], ?]] = M

    override val applicative: Applicative[G] = A

    override val monoidK: MonoidK[G] = K

    override def log(e: E): WriterT[F, G[E], Unit] =
      WriterT.tell(A.pure(e))

    override def clear[A](wt: WriterT[F, G[E], A]): WriterT[F, G[E], A] =
      wt.mapWritten(_ =&gt; K.empty)

    override def extract[A](wt: WriterT[F, G[E], A]): WriterT[F, G[E], (A, G[E])] =
      wt.mapBoth((ge, a) =&gt; (ge, (a, ge)))
  }
</code></pre>

<p>Be sure to check the <code>MonadLog</code> laws for the instance. Refer to the <a href="https://github.com/vlovgr/io-and-logging-capabilities">sources</a> to see how it&rsquo;s done.</p>

<h2 id="dispatching-messages">Dispatching Messages</h2>

<p>We&rsquo;re now ready to create an instance of our <code>Logging</code> algebra. In our case, we&rsquo;ll make use of <a href="https://www.slf4j.org">SL4J</a> and <a href="https://logback.qos.ch/">Logback</a> to define the dispatch function, but you&rsquo;re free to implement it with whatever logging library, or way of dispatching logs, you would like.</p>

<pre><code class="language-scala">import cats.effect.Sync
import org.slf4j.{LoggerFactory, MDC}

def createLogger[F[_], G[_]](
  implicit F: Sync[F],
  M: MonadLog[F, G, LogEntry],
  G: Foldable[G]
): F[Logging[F, G]] =
  F.delay(LoggerFactory.getLogger(&quot;App&quot;)).map { logger =&gt;
    Logging.create {
      case (message, mdc, level) =&gt; F.suspend {
        val levelEnabled = level match {
          case LogLevel.Error   =&gt; logger.isErrorEnabled
          case LogLevel.Warning =&gt; logger.isWarnEnabled
          case LogLevel.Info    =&gt; logger.isInfoEnabled
          case LogLevel.Debug   =&gt; logger.isDebugEnabled
        }

        if (levelEnabled) {
          val setContext =
            mdc.foldLeft(F.unit) { (ms, m) =&gt;
              ms *&gt; F.delay(MDC.put(m.key.value, m.value.value))
            }

          val resetContext =
            mdc.foldLeft(F.unit) { (ms, m) =&gt;
              ms *&gt; F.delay(MDC.remove(m.key.value)).void
            }

          F.bracket(setContext) { _ =&gt;
            F.delay(level match {
              case LogLevel.Error   =&gt; logger.error(message.value.value)
              case LogLevel.Warning =&gt; logger.warn(message.value.value)
              case LogLevel.Info    =&gt; logger.info(message.value.value)
              case LogLevel.Debug   =&gt; logger.debug(message.value.value)
            })
          }(_ =&gt; resetContext)
        } else F.unit
      }
    }
  }
</code></pre>

<h2 id="putting-it-together">Putting It Together</h2>

<p>We can now start to use our <code>Logging</code> algebra, either via functions, or as arguments to other algebras. In the example below, we&rsquo;ve defined a <code>Processing</code> algebra which makes use of the <code>Logging</code> algebra to log some details about how the request was processed.</p>

<pre><code class="language-scala">import cats.FlatMap
import cats.syntax.flatMap._
import LogEntry._

trait Processing[F[_]] {
  def processRequest(request: NonEmptyString): F[Unit]
}

object Processing {
  def create[F[_], G[_]](logging: Logging[F, G])(implicit F: FlatMap[F]): Processing[F] =
    new Processing[F] {
      import logging._

      override def processRequest(request: NonEmptyString): F[Unit] =
        for {
          _ &lt;- log(ReceivedRequest(request))
          _ &lt;- log(RequestStillFailing(3))
        } yield ()
    }
}
</code></pre>

<p>Finally, we&rsquo;re putting everything together inside <code>IOApp</code>.</p>

<pre><code class="language-scala">import cats.effect.{ExitCode, IOApp}

object App extends IOApp {
  override def run(args: List[String]): IO[ExitCode] = {
    val noMdc: Chain[MdcEntry] = Chain.empty

    (for {
      logging &lt;- createLogger[AIO, Chain]
      _ &lt;- logging.logNow(ApplicationStarted, noMdc)
      processing = Processing.create(logging)
      mdc = Chain.one(MdcEntry.TraceToken(&quot;traceToken&quot;))
      process = processing.processRequest(&quot;test&quot;)
      _ &lt;- logging.dispatchLogs(process, mdc)
    } yield ExitCode.Success).value
  }
}
</code></pre>

<p>The application outputs the following two log messages. The first one as <code>Info</code>, the second as <code>Error</code>.</p>

<pre><code class="language-nohighlight">Application started
</code></pre>

<pre><code class="language-nohighlight">- Received request: test
- Request still failing after 3 retries
</code></pre>

<p>We&rsquo;ve finally accomplished log accumulation and the third logging challenge: log entries relating to a single request can be accumulated, and logged together as a single message with diagnostic context.</p>

<h2 id="testing-logging">Testing Logging</h2>

<p>The fourth logging challenge relates to testing: how can we avoid to always assert on messages? When log entries are modelled as values with <code>LogEntry</code>s, this becomes rather easy. We&rsquo;ll start by defining a test implementation of the <code>Logging</code> algebra, which simply stores all dispatched messages in a <a href="https://typelevel.org/cats-effect/concurrency/ref.html"><code>Ref</code></a>, instead of dispatching log messages with a logging library.</p>

<pre><code class="language-scala">import cats.effect.concurrent.Ref
import cats.SemigroupK
import cats.syntax.semigroupk._

object TestLogging {
  def create[F[_], G[_]](logs: Ref[F, G[(NonEmptyString, G[MdcEntry], LogLevel)]])(
    implicit
    M: MonadLog[F, G, LogEntry],
    F: Foldable[G],
    S: SemigroupK[G],
    A: Applicative[G]
  ): Logging[F, G] =
    Logging.create {
      case (message, mdc, level) =&gt;
        logs.modify(g =&gt; (g.combineK((message.value, mdc, level).pure[G]), ()))
    }
}
</code></pre>

<p>We&rsquo;ll then define <code>Arbitrary</code> instances for <code>IOLog</code> and <code>LogEntry</code>, and <code>Eq</code> instances for <code>LogEntry</code> and <code>MdcEntry</code>. Note that <a href="https://github.com/fthomas/refined">refined</a> has a <a href="http://scalacheck.org/">ScalaCheck</a> module which provides <code>Arbitrary</code> instances for many refinement types, so we don&rsquo;t have to write them ourselves.</p>

<pre><code class="language-scala">import cats.Eq
import cats.syntax.eq._
import eu.timepit.refined.scalacheck.numeric._
import eu.timepit.refined.scalacheck.string._
import org.scalacheck.Arbitrary.arbitrary
import org.scalacheck.{Arbitrary, Gen}

trait AIOTestInstances {
  implicit def ioLogArbitrary[A, E](
    implicit
    ArbIOA: Arbitrary[IO[A]],
    ArbCE: Arbitrary[Chain[E]]
  ): Arbitrary[IOLog[A, E]] = Arbitrary {
    for {
      ioa &lt;- arbitrary[IO[A]]
      ce &lt;- arbitrary[Chain[E]]
    } yield WriterT(ioa.map((ce, _)))
  }

  implicit val logEntryArbitrary: Arbitrary[LogEntry] =
    Arbitrary {
      Gen.oneOf(
        Gen.const(ApplicationStarted),
        arbitrary[NonEmptyString].map(ReceivedRequest),
        arbitrary[NonNegInt].map(RequestStillFailing)
      )
    }

  implicit val logEntryEq: Eq[LogEntry] =
    Eq.instance {
      case (ApplicationStarted, ApplicationStarted)                  =&gt; true
      case (ApplicationStarted, _) | (_, ApplicationStarted)         =&gt; false
      case (ReceivedRequest(a), ReceivedRequest(b))                  =&gt; a === b
      case (ReceivedRequest(_), _) | (_, ReceivedRequest(_))         =&gt; false
      case (RequestStillFailing(a), RequestStillFailing(b))          =&gt; a === b
      case (RequestStillFailing(_), _) | (_, RequestStillFailing(_)) =&gt; false
    }

  implicit val mdcEntryEq: Eq[MdcEntry] =
    Eq.instance((a, b) =&gt; a.key === b.key &amp;&amp; a.value === b.value)
}
</code></pre>

<p>We can then write tests for the <code>Processing</code> algebra using the test <code>Logging</code> implementation. Note that we can assert both on accumulated log entries and on dispatched log messages. We&rsquo;re free to assert on accumulated logs by comparing <code>LogEntry</code>s, instead of always having to assert on messages.</p>

<pre><code class="language-scala">import cats.effect.ContextShift
import cats.effect.laws.util.TestContext
import cats.instances.tuple._
import org.scalatest.{Assertion, AsyncFunSpec}

final class ProcessingSpec extends AsyncFunSpec with AIOTestInstances {
  test(&quot;should accumulate two log entries&quot;) {
    case (_, logging, processing) =&gt;
      import logging._
      import processing._

      val request: NonEmptyString = &quot;test&quot;

      val expected =
        Chain.concat(
          Chain.one(ReceivedRequest(request)),
          Chain.one(RequestStillFailing(3))
        )

      extractLogs(processRequest(request))
        .map { case (_, logs) =&gt; assert(logs === expected) }
  }

  test(&quot;should dispatch a single log message&quot;) {
    case (logs, logging, processing) =&gt;
      import logging._
      import processing._

      val request: NonEmptyString = &quot;test&quot;

      val mdc = Chain.one(MdcEntry.TraceToken(&quot;traceToken&quot;))

      val message =
        NonEmptyString.unsafeFrom {
          show&quot;&quot;&quot;
                |- Received request: $request
                |- Request still failing after 3 retries
              &quot;&quot;&quot;.stripMargin.trim
        }

      val expected = Chain.one((message, mdc, LogLevel.Error))

      for {
        _ &lt;- dispatchLogs(processRequest(request), mdc)
        dispatchedLogs &lt;- logs.get
      } yield assert(dispatchedLogs === expected)
  }

  type Dispatched = Chain[(NonEmptyString, Chain[MdcEntry], LogLevel)]

  type TestInput = (Ref[AIO, Dispatched], Logging[AIO, Chain], Processing[AIO])

  def test(name: String)(f: TestInput =&gt; AIO[Assertion]): Unit = {
    implicit val contextShift: ContextShift[IO] =
      IO.contextShift(TestContext())

    it(name) {
      (for {
        logs &lt;- Ref.of[AIO, Dispatched](Chain.empty)
        logging = TestLogging.create(logs)
        processing = Processing.create(logging)
        assertion &lt;- f((logs, logging, processing))
      } yield assertion).value.unsafeToFuture()
    }
  }
}
</code></pre>

<h2 id="limitations">Limitations</h2>

<p>There is one important limitation to the outlined logging approach.</p>

<ul>
<li>When an error occurs, any accumulated log entries are lost. This is a consequence of keeping logs as values. If that&rsquo;s unacceptable for some logs, then resort to <code>logNow</code> for those entries. This means you might have to piece together the log entries later using an identifier in the diagnostic context.</li>
</ul>

<p>There is also one technical limitation worth knowing about.</p>

<ul>
<li>Logs captured in <code>asyncF</code>, and <code>release</code> of <code>bracketCase</code> (and <code>bracket</code>) will be discarded. (<a href="https://github.com/typelevel/cats-effect/issues/371"><del>#371</del></a>)</li>
</ul>

<h2 id="sources">Sources</h2>

<p>The code shown throughout this post is also available on <a href="https://github.com/vlovgr/io-and-logging-capabilities">GitHub</a>.</p></div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>
       
    </body>

</html>

